// Copyright (C) 2017 Gabriel Gouvine - All Rights Reserved

#pragma once

#include "hypergraph.h"

#include <boost/numeric/ublas/matrix.hpp>
#include <ostream>
#include <istream>
#include <iostream>
#include <iomanip>

namespace minipart {

template<class Index, class EdgeWeight, class Resource>
struct Problem {
  Hypergraph<Index, EdgeWeight> hypergraph;
  Matrix<Resource> demands;
  Matrix<Resource> capacities;
};

std::stringstream getHMetisLine(std::istream &s) {
  // Get rid of comment lines and empty lines
  std::string tmp;
  do {
    if (!s.good()) throw std::runtime_error("Not enough lines");
    std::getline(s, tmp);
  } while(tmp.empty() || tmp[0] == '%');

  return std::stringstream(tmp);
}

template <class Index, class EdgeWeight>
Hypergraph<Index, EdgeWeight> readHMetisGraph(std::istream &s, std::size_t nNodes, std::size_t nEdges, bool hasEdgeWeights) {
  std::stringstream ss;
  HypergraphBuilder<Index, EdgeWeight> h(nNodes);

  std::vector<Node<Index> > nodes;
  for (std::size_t i = 0; i < nEdges; ++i) {
    ss = getHMetisLine(s);

    EdgeWeight w = 1;
    if (hasEdgeWeights) ss >> w;

    while (ss) {
        Index n;
        ss >> n;
        if (ss.fail()) continue;
        if (n >= nNodes) throw std::runtime_error("Parsed pin index is outside the specified number of nodes");
        nodes.emplace_back(n);
    }
    if (nodes.empty()) throw std::runtime_error("No node on the line");

    h.addEdge(nodes.begin(), nodes.end(), w);

    nodes.clear();
  }

  return h;
}

template <class Resource>
Matrix<Resource> readHMetisResources(std::istream &s, std::size_t nNodes, bool hasNodeWeights) {
  std::stringstream ss;
  Matrix<Resource> r(nNodes, 1);
  if (hasNodeWeights) {
    std::vector<Resource> resources;
    for (std::size_t i = 0; i < nNodes; ++i) {
      ss = getHMetisLine(s);
      while (ss) {
        Resource w;
        ss >> w;
        if (ss.fail()) continue;
        resources.push_back(w);
      }
      if (i == 0) r = Matrix<Resource>(nNodes, resources.size());
      if (resources.size() != r.size2()) throw std::runtime_error("Inconsistent number of node weights");
      for (std::size_t j = 0; j < r.size2(); ++j) {
        r(i, j) = resources[j];
      }
      resources.clear();
    }
  }
  else {
    for (std::size_t i = 0; i < nNodes; ++i) {
      r(i, 0) = 1;
    }
  }

  return r;
}

template <class Index, class EdgeWeight, class Resource>
Problem<Index, EdgeWeight, Resource> readHMetis(std::istream &s) {
  Problem<Index, EdgeWeight, Resource> ret;

  std::size_t nNodes, nEdges, params;

  std::stringstream ss = getHMetisLine(s);
  ss >> nNodes >> nEdges >> params;
  if (ss.fail()) params = 0;

  if (params != 0 && params != 1 && params != 10 && params != 11) throw std::runtime_error("Invalid parameter value");

  bool hasEdgeWeights = (params == 11) || (params == 1);
  bool hasNodeWeights = (params == 11) || (params == 10);

  ret.hypergraph = readHMetisGraph<Index, EdgeWeight>(s, nNodes, nEdges, hasEdgeWeights);
  ret.demands = readHMetisResources<Resource>(s, nNodes, hasNodeWeights);
  return ret;
}

template<class Index, class EdgeWeight, class Resource>
void writeHMetis(const Problem<Index, EdgeWeight, Resource> &pb, std::ostream &s) {
  s << "% HGR (hMetis) file generated by Minipart" << std::endl;

  const Hypergraph<Index, EdgeWeight> &h = pb.hypergraph;
  const Matrix<Resource> &r = pb.demands;

  s << "% " << h.nNodes() << " nodes, " << h.nEdges() << " edges" << std::endl;
  if (r.size2() > 1) {
    s << "% Multiple (" << r.size2() << ") node weights: this file might not be readable by other tools" << std::endl;
  }
  s << "%" << std::endl;

  s << h.nNodes() << " " << h.nEdges();
  s << " 11" << std::endl; // Edge and node weights

  for (auto e : h.edges()) {
    s << h.weight(e);
    for (auto n : h.nodes(e)) {
      s << " " << n.id;
    }
    s << std::endl;
  }

  for (std::size_t i = 0; i < r.size1(); ++i) {
    for (std::size_t j = 0; j < r.size2(); ++j) {
      s << r(i, j) << " ";
    }
    s << std::endl;
  }

}

}  // End namespace minipart

